> 说明：当前前端版本不包含数据库功能。本文件仅作为参考资料保留，前端不落库。

# 数据库相关需求补充说明

1. 拟采用pymysql + SQLAlchemy 模块编程
2. 设备在接收到串口数据后，需插入到数据库，应考虑异步处理
3. 每个设备的数据均保存到本地数据库，并通过WebSocket定时上传至系统总服务器
4. 数据库配置从config.ini配置文件获取

### 数据库表结构定义

-- ============================================
-- 钢轨电位限制柜数据库DDL
-- 包含分区表结构、索引、自动分区管理
-- ============================================

-- 设置时区和字符集

```mysql
SET NAMES utf8mb4;
SET TIME_ZONE = '+08:00';
```

-- ============================================
-- 1. 状态历史表（分区表）
-- ============================================

```mysql
CREATE TABLE IF NOT EXISTS status_history (
    id BIGINT AUTO_INCREMENT COMMENT '主键ID',
    record_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '记录插入时间',
    timestamp DATETIME(3) NOT NULL COMMENT '状态变化时间戳（毫秒精度）',
    status_type VARCHAR(50) NOT NULL COMMENT '状态类型：WorkStatus/OutputStatus/FaultStatus/InputStatus',
    bit_position INT NOT NULL COMMENT '位位置（0-15）',
    old_value TINYINT NOT NULL COMMENT '变化前的状态值（0或1）',
    new_value TINYINT NOT NULL COMMENT '变化后的状态值（0或1）',
    status_name VARCHAR(100) NOT NULL COMMENT '状态名称描述',
    device_id VARCHAR(50) NOT NULL COMMENT '设备ID',
    upload_status TINYINT DEFAULT 0 COMMENT '上传状态：0-待上传，1-已上传，2-上传失败',
    upload_time DATETIME COMMENT '实际上传时间',
    retry_count TINYINT DEFAULT 0 COMMENT '重试次数',
    last_error VARCHAR(255) COMMENT '最后错误信息',
    PRIMARY KEY (id, timestamp),
    INDEX idx_device_time (device_id, timestamp),
    INDEX idx_upload (upload_status, upload_time),
    INDEX idx_status_type (status_type, timestamp)
) ENGINE=InnoDB 
DEFAULT CHARSET=utf8mb4 
COLLATE=utf8mb4_unicode_ci
COMMENT='状态历史表-记录开关量/系统状态/故障信息变化'
PARTITION BY RANGE (TO_DAYS(timestamp)) (
    PARTITION p202410 VALUES LESS THAN (TO_DAYS('2024-11-01')),
    PARTITION p202411 VALUES LESS THAN (TO_DAYS('2024-12-01')),
    PARTITION p202412 VALUES LESS THAN (TO_DAYS('2025-01-01')),
    PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
    PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
    PARTITION p202503 VALUES LESS THAN (TO_DAYS('2025-04-01')),
    PARTITION p202504 VALUES LESS THAN (TO_DAYS('2025-05-01')),
    PARTITION p202505 VALUES LESS THAN (TO_DAYS('2025-06-01')),
    PARTITION p202506 VALUES LESS THAN (TO_DAYS('2025-07-01')),
    PARTITION p202507 VALUES LESS THAN (TO_DAYS('2025-08-01')),
    PARTITION p202508 VALUES LESS THAN (TO_DAYS('2025-09-01')),
    PARTITION p202509 VALUES LESS THAN (TO_DAYS('2025-10-01')),
    PARTITION p202510 VALUES LESS THAN (TO_DAYS('2025-11-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

-- ============================================
-- 2. 实时数据表（分区表）
-- ============================================

```mysql
CREATE TABLE IF NOT EXISTS real_time_data (
    id BIGINT AUTO_INCREMENT COMMENT '主键ID',
    timestamp DATETIME(3) NOT NULL COMMENT '数据采集时间戳（毫秒精度）',
    device_id VARCHAR(50) NOT NULL COMMENT '设备ID',
    parameter_name VARCHAR(50) NOT NULL COMMENT '模拟量名称（如SV1/SA1）',
    value DECIMAL(10,3) NOT NULL COMMENT '模拟量值',
    unit VARCHAR(10) NOT NULL COMMENT '单位（如V/A/℃）',
    upload_status TINYINT DEFAULT 0 COMMENT '上传状态：0-待上传，1-已上传，2-上传失败',
    upload_time DATETIME COMMENT '实际上传时间',
    retry_count TINYINT DEFAULT 0 COMMENT '重试次数',
    last_error VARCHAR(255) COMMENT '最后错误信息',
    PRIMARY KEY (id, timestamp),
    INDEX idx_device_time (device_id, timestamp),
    INDEX idx_param_time (parameter_name, timestamp),
    INDEX idx_upload (upload_status, upload_time)
) ENGINE=InnoDB 
DEFAULT CHARSET=utf8mb4 
COLLATE=utf8mb4_unicode_ci
COMMENT='实时数据表-记录模拟量数据'
PARTITION BY RANGE (TO_DAYS(timestamp)) (
    PARTITION p202410 VALUES LESS THAN (TO_DAYS('2024-11-01')),
    PARTITION p202411 VALUES LESS THAN (TO_DAYS('2024-12-01')),
    PARTITION p202412 VALUES LESS THAN (TO_DAYS('2025-01-01')),
    PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
    PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
    PARTITION p202503 VALUES LESS THAN (TO_DAYS('2025-04-01')),
    PARTITION p202504 VALUES LESS THAN (TO_DAYS('2025-05-01')),
    PARTITION p202505 VALUES LESS THAN (TO_DAYS('2025-06-01')),
    PARTITION p202506 VALUES LESS THAN (TO_DAYS('2025-07-01')),
    PARTITION p202507 VALUES LESS THAN (TO_DAYS('2025-08-01')),
    PARTITION p202508 VALUES LESS THAN (TO_DAYS('2025-09-01')),
    PARTITION p202509 VALUES LESS THAN (TO_DAYS('2025-10-01')),
    PARTITION p202510 VALUES LESS THAN (TO_DAYS('2025-11-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

-- ============================================
-- 3. 事件记录表（分区表）
-- ============================================

```mysql
CREATE TABLE IF NOT EXISTS event_records (
    id BIGINT AUTO_INCREMENT COMMENT '主键ID',
    event_time DATETIME(3) NOT NULL COMMENT '事件发生时间戳（毫秒精度）',
    event_type VARCHAR(50) NOT NULL COMMENT '事件类型',
    device_id VARCHAR(50) NOT NULL COMMENT '设备ID',
    description TEXT COMMENT '事件描述',
    upload_status TINYINT DEFAULT 0 COMMENT '上传状态：0-待上传，1-已上传，2-上传失败',
    upload_time DATETIME COMMENT '实际上传时间',
    retry_count TINYINT DEFAULT 0 COMMENT '重试次数',
    last_error VARCHAR(255) COMMENT '最后错误信息',
    PRIMARY KEY (id, event_time),
    INDEX idx_device_time (device_id, event_time),
    INDEX idx_event_type (event_type, event_time),
    INDEX idx_upload (upload_status, upload_time)
) ENGINE=InnoDB 
DEFAULT CHARSET=utf8mb4 
COLLATE=utf8mb4_unicode_ci
COMMENT='事件记录表-记录系统事件/连接信息/登录信息'
PARTITION BY RANGE (TO_DAYS(event_time)) (
    PARTITION p202410 VALUES LESS THAN (TO_DAYS('2024-11-01')),
    PARTITION p202411 VALUES LESS THAN (TO_DAYS('2024-12-01')),
    PARTITION p202412 VALUES LESS THAN (TO_DAYS('2025-01-01')),
    PARTITION p202501 VALUES LESS THAN (TO_DAYS('2025-02-01')),
    PARTITION p202502 VALUES LESS THAN (TO_DAYS('2025-03-01')),
    PARTITION p202503 VALUES LESS THAN (TO_DAYS('2025-04-01')),
    PARTITION p202504 VALUES LESS THAN (TO_DAYS('2025-05-01')),
    PARTITION p202505 VALUES LESS THAN (TO_DAYS('2025-06-01')),
    PARTITION p202506 VALUES LESS THAN (TO_DAYS('2025-07-01')),
    PARTITION p202507 VALUES LESS THAN (TO_DAYS('2025-08-01')),
    PARTITION p202508 VALUES LESS THAN (TO_DAYS('2025-09-01')),
    PARTITION p202509 VALUES LESS THAN (TO_DAYS('2025-10-01')),
    PARTITION p202510 VALUES LESS THAN (TO_DAYS('2025-11-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

-- ============================================
-- 4. 用户权限表（可选，用于权限控制）
-- ============================================

```mysql
CREATE TABLE IF NOT EXISTS user_permissions (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '主键ID',
    user_id VARCHAR(50) NOT NULL UNIQUE COMMENT '用户ID',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    permission_type VARCHAR(50) NOT NULL DEFAULT 'view_only' COMMENT '权限类型：view_only/control/admin',
    allowed_commands JSON COMMENT '允许执行的指令列表',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    last_login DATETIME COMMENT '最后登录时间',
    is_active TINYINT DEFAULT 1 COMMENT '是否激活：1-激活，0-禁用',
    INDEX idx_user_id (user_id)
) ENGINE=InnoDB 
DEFAULT CHARSET=utf8mb4 
COLLATE=utf8mb4_unicode_ci
COMMENT='用户权限表';
```

-- ============================================
-- 5. 分区管理存储过程
-- ============================================    

```mysql
DELIMITER $$

-- 5.1 创建新分区的存储过程
CREATE PROCEDURE manage_partitions()
BEGIN
    DECLARE next_month_date DATE;
    DECLARE next_month_name VARCHAR(10);
    DECLARE partition_exists INT;
-- 计算下个月的第一天
SET next_month_date = DATE_ADD(LAST_DAY(CURDATE()), INTERVAL 1 DAY);
SET next_month_name = CONCAT('p', DATE_FORMAT(next_month_date, '%Y%m'));

-- 检查status_history表是否已存在该分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'status_history' 
AND partition_name = next_month_name;

IF partition_exists = 0 THEN
    -- 为status_history添加新分区
    SET @sql = CONCAT(
        'ALTER TABLE status_history REORGANIZE PARTITION p_future INTO (',
        'PARTITION ', next_month_name, ' VALUES LESS THAN (TO_DAYS(\'',
        DATE_FORMAT(DATE_ADD(next_month_date, INTERVAL 1 MONTH), '%Y-%m-01'),
        '\')),',
        'PARTITION p_future VALUES LESS THAN MAXVALUE)'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;

-- 为real_time_data表添加新分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'real_time_data' 
AND partition_name = next_month_name;

IF partition_exists = 0 THEN
    SET @sql = CONCAT(
        'ALTER TABLE real_time_data REORGANIZE PARTITION p_future INTO (',
        'PARTITION ', next_month_name, ' VALUES LESS THAN (TO_DAYS(\'',
        DATE_FORMAT(DATE_ADD(next_month_date, INTERVAL 1 MONTH), '%Y-%m-01'),
        '\')),',
        'PARTITION p_future VALUES LESS THAN MAXVALUE)'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;

-- 为event_records表添加新分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'event_records' 
AND partition_name = next_month_name;

IF partition_exists = 0 THEN
    SET @sql = CONCAT(
        'ALTER TABLE event_records REORGANIZE PARTITION p_future INTO (',
        'PARTITION ', next_month_name, ' VALUES LESS THAN (TO_DAYS(\'',
        DATE_FORMAT(DATE_ADD(next_month_date, INTERVAL 1 MONTH), '%Y-%m-01'),
        '\')),',
        'PARTITION p_future VALUES LESS THAN MAXVALUE)'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;
END$$

-- 5.2 删除旧分区的存储过程（保留13个月数据）
CREATE PROCEDURE cleanup_old_partitions()
BEGIN
    DECLARE old_partition_date DATE;
    DECLARE old_partition_name VARCHAR(10);
    DECLARE partition_exists INT;
    
-- 计算13个月前的分区名称
SET old_partition_date = DATE_SUB(CURDATE(), INTERVAL 13 MONTH);
SET old_partition_name = CONCAT('p', DATE_FORMAT(old_partition_date, '%Y%m'));

-- 删除status_history的旧分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'status_history' 
AND partition_name = old_partition_name;

IF partition_exists > 0 THEN
    SET @sql = CONCAT('ALTER TABLE status_history DROP PARTITION ', old_partition_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;

-- 删除real_time_data的旧分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'real_time_data' 
AND partition_name = old_partition_name;

IF partition_exists > 0 THEN
    SET @sql = CONCAT('ALTER TABLE real_time_data DROP PARTITION ', old_partition_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;

-- 删除event_records的旧分区
SELECT COUNT(*) INTO partition_exists 
FROM information_schema.partitions 
WHERE table_schema = DATABASE() 
AND table_name = 'event_records' 
AND partition_name = old_partition_name;

IF partition_exists > 0 THEN
    SET @sql = CONCAT('ALTER TABLE event_records DROP PARTITION ', old_partition_name);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END IF;
END$$

DELIMITER ;
```
-- ============================================
-- 6. 创建MySQL事件调度器（自动执行分区管理）
-- ============================================

```mysql
-- 启用事件调度器
SET GLOBAL event_scheduler = ON;

-- 每月1日凌晨2点创建新分区
CREATE EVENT IF NOT EXISTS evt_create_monthly_partitions
ON SCHEDULE EVERY 1 MONTH
STARTS (TIMESTAMP(CURRENT_DATE) + INTERVAL 1 MONTH + INTERVAL 2 HOUR)
DO CALL manage_partitions();

-- 每月1日凌晨3点删除13个月前的旧分区
CREATE EVENT IF NOT EXISTS evt_cleanup_old_partitions
ON SCHEDULE EVERY 1 MONTH
STARTS (TIMESTAMP(CURRENT_DATE) + INTERVAL 1 MONTH + INTERVAL 3 HOUR)
DO CALL cleanup_old_partitions();
```

-- ============================================
-- 7. 查看分区信息的视图
-- ============================================

```mysql
CREATE OR REPLACE VIEW v_partition_info AS
SELECT 
    table_name,
    partition_name,
    partition_ordinal_position AS position,
    partition_method,
    partition_expression,
    partition_description AS upper_bound,
    table_rows,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    create_time,
    update_time
FROM information_schema.partitions
WHERE table_schema = DATABASE()
AND table_name IN ('status_history', 'real_time_data', 'event_records')
ORDER BY table_name, partition_ordinal_position;
```

-- ============================================
-- 8. 常用查询示例
-- ============================================

```mysql
-- 查看所有分区信息
-- SELECT * FROM v_partition_info;

-- 手动创建下个月分区（仅需在首次部署时执行一次）
-- CALL manage_partitions();

-- 手动删除旧分区
-- CALL cleanup_old_partitions();

-- 查询待上传数据条数
-- SELECT 
--     'status_history' AS table_name,
--     COUNT(*) AS pending_count
-- FROM status_history 
-- WHERE upload_status IN (0, 2)
-- UNION ALL
-- SELECT 
--     'real_time_data' AS table_name,
--     COUNT(*) AS pending_count
-- FROM real_time_data 
-- WHERE upload_status IN (0, 2);

-- 查询最近1小时的数据量
-- SELECT 
--     COUNT(*) AS total_records,
--     COUNT(DISTINCT device_id) AS device_count
-- FROM real_time_data
-- WHERE timestamp >= NOW() - INTERVAL 1 HOUR;
```

-- ============================================
-- 完成
-- ============================================